transitivity <- transitivity(g)
odd_rho <- rho / (1 - rho)
odd_transitivity <- transitivity / (1 - transitivity)
tau <- odd_transitivity / odd_rho
continent_assortativity <- assortativity(g, V(g)$continent, directed = TRUE)
gdp_assortativity <- assortativity(g, V(g)$gdp, directed = TRUE)
partition_assortativity <- assortativity(g, V(g)$partition, directed = TRUE)
in_degree <- degree(g, mode = "in")
out_degree <- degree(g, mode = "out")
st_in_degree <- degree(g, mode = "in", normalized = TRUE)
st_out_degree <- degree(g, mode = "out", normalized = TRUE)
closeness_in <- closeness(g, mode = "in") #non torna???
closeness_out <- closeness(g, mode = "out")
st_closeness_in <- closeness(g, mode = "in", normalized = TRUE)
st_closeness_in <- closeness(g, mode = "in", normalized = TRUE)
betweenness <- betweenness(g, directed = TRUE)
st_betweenness <- betweenness(g, directed = TRUE, normalized = TRUE)
eigen_centrality <- eigen_centrality(g)$vector
st_eigen_centrality <- eigen_centrality(g, scale = TRUE)$vector
in_centr_degree <- centr_degree(g, loops = FALSE, mode = "in")
out_centr_degree <- centr_degree(g, loops = FALSE, mode = "out")
in_centr_clo <- centr_clo(g, mode = "in")
out_centr_clo <- centr_clo(g, mode = "out")
centr_betw <- centr_betw(g, directed = TRUE)
summary(in_degree)
summary(st_in_degree)
hist(in_degree, breaks = length(unique(in_degree)))
hist(st_in_degree, breaks = length(unique(st_in_degree)))
plot(g, vertex.size = 10 * in_degree)
plot(g, vertex.size = in_degree)
max(in_degree)
hist(in_degree)
summary(in_degree)
plot(g, vertex.size = out_degree)
summary(out_degree)
summary(betweenness)
plot(g, vertex.size = betweenness * 0.05)
plot(g, vertex.size = eigen_centrality * 0.05)
plot(g, vertex.size = eigen_centrality * 20)
summary(eigen_centrality)
n <- vcount(g)
B <- 1000
m <-  sum(Y, na.rm = TRUE)
#CId.sim = C.sim = c() statistiche da simulare
for (b in 1: B) {
Y_sim <- matrix(NA, n, n)
ones <- rep(1, m)
zeros <- rep(0, n * (n - 1) - m)
all <- c(ones, zeros)
Y_sim[col(Y_sim) != row(Y_sim)] <- sample(all, n * (n - 1))
g_sim <- graph_from_adjacency_matrix(Y_sim)
#C.sim[b] = transitivity(g.sim)
}
aRect_fnc = function(Y, k){
# Y = adjacency matrix
# k = n. of steps in the alternating rectangles algorithm
Y1 = matrix(c(0,1,1,0), 2, 2)
Y2 = 1 - Y1
n = nrow(Y)
for(s in 1:k){
# draw 4 distinct indexes
# two rows and two columns
ij = sample(1:n,4,replace = F)
# select the corresponst_in_degreeg sub-matrix
rows = ij[1:2]
cols = ij[3:4]
Yij = Y[rows, cols]
# perturbation
if(all(Yij == Y1)) Yij = Y2 else if(all(Yij == Y2))  Yij = Y1
Y[rows, cols] = Yij
}
return(Y)
}
st_in_sim = st_out_sim = recip_sim = c()
for(b in 1:1000){
Y_sim = aRect_fnc(Y, 100)
# print number of perturbed elements in Y.sim
cat(sum(Y != Y_sim, na.rm = T), "*", sep="")
g_sim = graph_from_adjacency_matrix(Y_sim)
st_in_sim[b] = sd(degree(g_sim, mode = "in"))
st_out_sim[b] = sd(degree(g_sim, mode = "out"))
recip_sim[b] = reciprocity(g_sim)
}
hist(st_out_sim)
abline(v = sd(st_out_degree), col = "red", lty = 2)
st_out_sim
hist(recip_sim)
abline(v = reciprocity, col = "red", lty = 2)
# p-value
mean(st_in_sim > sd(st_in_degree))
mean(st_out_sim > sd(st_out_degree))
mean(recip_sim > reciprocity)
load("~/R files/Project/.RData")
aRect_fnc = function(Y, k){
# Y = adjacency matrix
# k = n. of steps in the alternating rectangles algorithm
Y1 = matrix(c(0,1,1,0), 2, 2)
Y2 = 1 - Y1
n = nrow(Y)
for(s in 1:k){
# draw 4 distinct indexes
# two rows and two columns
ij = sample(1:n,4,replace = F)
# select the corresponst_in_degreeg sub-matrix
rows = ij[1:2]
cols = ij[3:4]
Yij = Y[rows, cols]
# perturbation
if(all(Yij == Y1)) Yij = Y2 else if(all(Yij == Y2))  Yij = Y1
Y[rows, cols] = Yij
}
return(Y)
}
st_in_sim = st_out_sim = recip_sim = c()
for(b in 1:1000){
Y_sim = aRect_fnc(Y, 100)
# print number of perturbed elements in Y.sim
cat(sum(Y != Y_sim, na.rm = T), "*", sep="")
g_sim = graph_from_adjacency_matrix(Y_sim)
st_in_sim[b] = sd(degree(g_sim, mode = "in"))
st_out_sim[b] = sd(degree(g_sim, mode = "out"))
recip_sim[b] = reciprocity(g_sim)
}
ls()
Y <- as_adjacency_matrix(g, names = FALSE)
diag(Y) = NA
rho <- edge_density(g)
reciprocity <- reciprocity(g)
transitivity <- transitivity(g)
odd_rho <- rho / (1 - rho)
odd_transitivity <- transitivity / (1 - transitivity)
tau <- odd_transitivity / odd_rho
continent_assortativity <- assortativity(g, V(g)$continent, directed = TRUE)
gdp_assortativity <- assortativity(g, V(g)$gdp, directed = TRUE)
partition_assortativity <- assortativity(g, V(g)$partition, directed = TRUE)
in_degree <- degree(g, mode = "in")
out_degree <- degree(g, mode = "out")
st_in_degree <- degree(g, mode = "in", normalized = TRUE)
st_out_degree <- degree(g, mode = "out", normalized = TRUE)
closeness_in <- closeness(g, mode = "in") #non torna???
closeness_out <- closeness(g, mode = "out")
st_closeness_in <- closeness(g, mode = "in", normalized = TRUE)
st_closeness_in <- closeness(g, mode = "in", normalized = TRUE)
betweenness <- betweenness(g, directed = TRUE)
st_betweenness <- betweenness(g, directed = TRUE, normalized = TRUE)
eigen_centrality <- eigen_centrality(g)$vector
st_eigen_centrality <- eigen_centrality(g, scale = TRUE)$vector
in_centr_degree <- centr_degree(g, loops = FALSE, mode = "in")
out_centr_degree <- centr_degree(g, loops = FALSE, mode = "out")
in_centr_clo <- centr_clo(g, mode = "in")
out_centr_clo <- centr_clo(g, mode = "out")
centr_betw <- centr_betw(g, directed = TRUE)
summary(in_degree)
summary(st_in_degree)
hist(in_degree, breaks = length(unique(in_degree)))
hist(st_in_degree, breaks = length(unique(st_in_degree)))
plot(g, vertex.size = 10 * in_degree)
plot(g, vertex.size = in_degree)
max(in_degree)
hist(in_degree)
summary(in_degree)
plot(g, vertex.size = out_degree)
summary(out_degree)
summary(betweenness)
plot(g, vertex.size = betweenness * 0.05)
plot(g, vertex.size = eigen_centrality * 0.05)
plot(g, vertex.size = eigen_centrality * 20)
summary(eigen_centrality)
n <- vcount(g)
B <- 1000
m <-  sum(Y, na.rm = TRUE)
#CId.sim = C.sim = c() statistiche da simulare
for (b in 1: B) {
Y_sim <- matrix(NA, n, n)
ones <- rep(1, m)
zeros <- rep(0, n * (n - 1) - m)
all <- c(ones, zeros)
Y_sim[col(Y_sim) != row(Y_sim)] <- sample(all, n * (n - 1))
g_sim <- graph_from_adjacency_matrix(Y_sim)
#C.sim[b] = transitivity(g.sim)
}
aRect_fnc = function(Y, k){
# Y = adjacency matrix
# k = n. of steps in the alternating rectangles algorithm
Y1 = matrix(c(0,1,1,0), 2, 2)
Y2 = 1 - Y1
n = nrow(Y)
for(s in 1:k){
# draw 4 distinct indexes
# two rows and two columns
ij = sample(1:n,4,replace = F)
# select the corresponst_in_degreeg sub-matrix
rows = ij[1:2]
cols = ij[3:4]
Yij = Y[rows, cols]
# perturbation
if(all(Yij == Y1)) Yij = Y2 else if(all(Yij == Y2))  Yij = Y1
Y[rows, cols] = Yij
}
return(Y)
}
st_in_sim = st_out_sim = recip_sim = c()
for(b in 1:1000){
Y_sim = aRect_fnc(Y, 100)
# print number of perturbed elements in Y.sim
cat(sum(Y != Y_sim, na.rm = T), "*", sep="")
g_sim = graph_from_adjacency_matrix(Y_sim)
st_in_sim[b] = sd(degree(g_sim, mode = "in"))
st_out_sim[b] = sd(degree(g_sim, mode = "out"))
recip_sim[b] = reciprocity(g_sim)
}
load("~/R files/Project/.RData")
diag(Y) = NA
rho <- edge_density(g)
reciprocity <- reciprocity(g)
transitivity <- transitivity(g)
odd_rho <- rho / (1 - rho)
odd_transitivity <- transitivity / (1 - transitivity)
tau <- odd_transitivity / odd_rho
continent_assortativity <- assortativity(g, V(g)$continent, directed = TRUE)
gdp_assortativity <- assortativity(g, V(g)$gdp, directed = TRUE)
partition_assortativity <- assortativity(g, V(g)$partition, directed = TRUE)
in_degree <- degree(g, mode = "in")
out_degree <- degree(g, mode = "out")
st_in_degree <- degree(g, mode = "in", normalized = TRUE)
st_out_degree <- degree(g, mode = "out", normalized = TRUE)
closeness_in <- closeness(g, mode = "in") #non torna???
closeness_out <- closeness(g, mode = "out")
st_closeness_in <- closeness(g, mode = "in", normalized = TRUE)
st_closeness_in <- closeness(g, mode = "in", normalized = TRUE)
betweenness <- betweenness(g, directed = TRUE)
st_betweenness <- betweenness(g, directed = TRUE, normalized = TRUE)
eigen_centrality <- eigen_centrality(g)$vector
st_eigen_centrality <- eigen_centrality(g, scale = TRUE)$vector
in_centr_degree <- centr_degree(g, loops = FALSE, mode = "in")
out_centr_degree <- centr_degree(g, loops = FALSE, mode = "out")
in_centr_clo <- centr_clo(g, mode = "in")
out_centr_clo <- centr_clo(g, mode = "out")
centr_betw <- centr_betw(g, directed = TRUE)
summary(in_degree)
summary(st_in_degree)
hist(in_degree, breaks = length(unique(in_degree)))
hist(st_in_degree, breaks = length(unique(st_in_degree)))
plot(g, vertex.size = 10 * in_degree)
plot(g, vertex.size = in_degree)
max(in_degree)
hist(in_degree)
summary(in_degree)
plot(g, vertex.size = out_degree)
summary(out_degree)
summary(betweenness)
plot(g, vertex.size = betweenness * 0.05)
plot(g, vertex.size = eigen_centrality * 0.05)
plot(g, vertex.size = eigen_centrality * 20)
summary(eigen_centrality)
n <- vcount(g)
B <- 1000
m <-  sum(Y, na.rm = TRUE)
#CId.sim = C.sim = c() statistiche da simulare
for (b in 1: B) {
Y_sim <- matrix(NA, n, n)
ones <- rep(1, m)
zeros <- rep(0, n * (n - 1) - m)
all <- c(ones, zeros)
Y_sim[col(Y_sim) != row(Y_sim)] <- sample(all, n * (n - 1))
g_sim <- graph_from_adjacency_matrix(Y_sim)
#C.sim[b] = transitivity(g.sim)
}
aRect_fnc = function(Y, k){
# Y = adjacency matrix
# k = n. of steps in the alternating rectangles algorithm
Y1 = matrix(c(0,1,1,0), 2, 2)
Y2 = 1 - Y1
n = nrow(Y)
for(s in 1:k){
# draw 4 distinct indexes
# two rows and two columns
ij = sample(1:n,4,replace = F)
# select the corresponst_in_degreeg sub-matrix
rows = ij[1:2]
cols = ij[3:4]
Yij = Y[rows, cols]
# perturbation
if(all(Yij == Y1)) Yij = Y2 else if(all(Yij == Y2))  Yij = Y1
Y[rows, cols] = Yij
}
return(Y)
}
st_in_sim = st_out_sim = recip_sim = c()
for(b in 1:1000){
Y_sim = aRect_fnc(Y, 100)
# print number of perturbed elements in Y.sim
cat(sum(Y != Y_sim, na.rm = T), "*", sep="")
g_sim = graph_from_adjacency_matrix(Y_sim)
st_in_sim[b] = sd(degree(g_sim, mode = "in"))
st_out_sim[b] = sd(degree(g_sim, mode = "out"))
recip_sim[b] = reciprocity(g_sim)
}
# p-value
mean(st_in_sim > sd(st_in_degree))
mean(st_out_sim > sd(st_out_degree))
st_in_sim = st_out_sim = recip_sim = c()
for(b in 1:1000){
Y_sim = aRect_fnc(Y, 100)
# print number of perturbed elements in Y.sim
cat(sum(Y != Y_sim, na.rm = T), "*", sep="")
g_sim = graph_from_adjacency_matrix(Y_sim)
st_in_sim[b] = sd(degree(g_sim, mode = "in"))
st_out_sim[b] = sd(degree(g_sim, mode = "out"))
recip_sim[b] = reciprocity(g_sim)
}
View(Y_sim)
View(Y)
View(Y_sim)
View(Y)
View(Y_sim)
load("~/R files/Project/.RData")
load("~/R files/Project/workspace.RData")
aRect_fnc = function(Y, k){
# Y = adjacency matrix
# k = n. of steps in the alternating rectangles algorithm
Y1 = matrix(c(0,1,1,0), 2, 2)
Y2 = 1 - Y1
n = nrow(Y)
for(s in 1:k){
# draw 4 distinct indexes
# two rows and two columns
ij = sample(1:n,4,replace = F)
# select the corresponst_in_degreeg sub-matrix
rows = ij[1:2]
cols = ij[3:4]
Yij = Y[rows, cols]
# perturbation
if(all(Yij == Y1)) Yij = Y2 else if(all(Yij == Y2))  Yij = Y1
Y[rows, cols] = Yij
}
return(Y)
}
st_in_sim = st_out_sim = recip_sim = c()
for(b in 1:1000){
Y_sim = aRect_fnc(Y, 100)
# print number of perturbed elements in Y.sim
cat(sum(Y != Y_sim, na.rm = T), "*", sep="")
g_sim = graph_from_adjacency_matrix(Y_sim)
st_in_sim[b] = sd(degree(g_sim, mode = "in"))
st_out_sim[b] = sd(degree(g_sim, mode = "out"))
recip_sim[b] = reciprocity(g_sim)
}
for(b in 1:1000){
Y_sim = aRect_fnc(Y, 100)
# print number of perturbed elements in Y.sim
cat(sum(Y != Y_sim, na.rm = T), "*", sep="")
g_sim = graph_from_adjacency_matrix(Y_sim)
st_in_sim[b] = sd(degree(g_sim, mode = "in"))
st_out_sim[b] = sd(degree(g_sim, mode = "out"))
recip_sim[b] = reciprocity(g_sim)
}
install.packages("sbm")
library(sbm)
library(igraph)
library(ggplot2)
data("fungusTreeNetwork")
?fungusTreeNetwork
# adjacency matrix
Yw = fungusTreeNetwork$tree_tree
str(Yw)
# let us binarize the matrix
Y = (Yw != 0) * 1
# let us derive the graph
graph = graph_from_adjacency_matrix(Y, mode = "undirected")
par(mar = c(4,4,2,2))
plot(graph)
# but let also represent the adjacency matrix graphically
?plotMyMatrix
plotMyMatrix(Y, dimLabels = list(row = 'tree', col = 'tree'))
# let us estimate a sbm
?estimateSimpleSBM
sbm1 = estimateSimpleSBM(Y, "bernoulli", dimLabels = 'tree',
estimOptions = list(verbosity = 1))
# let us look at the results
sbm1
# selected number of blocks
sbm1$nbBlocks
# prior block probabilities
sbm1$blockProp
# connectivity parameters
round(sbm1$connectParam$mean,3)
# a clearer representation
# ------------------------
plot(sbm1, type = "data")
# nodes are ordered wrt to the block they belong to and blocks are highlighted
plot(sbm1, type = "expected")
# fitted connection probabilities
plot(sbm1, type = "meso")
# a clearer representation
# ------------------------
plot(sbm1, type = "data")
# selected number of blocks
sbm1$nbBlocks
# let us look at the results
sbm1
# selected number of blocks
sbm1$nbBlocks
# prior block probabilities
sbm1$blockProp
# connectivity parameters
round(sbm1$connectParam$mean,3)
# a clearer representation
# ------------------------
plot(sbm1, type = "data")
# nodes are ordered wrt to the block they belong to and blocks are highlighted
plot(sbm1, type = "expected")
# a clearer representation
# ------------------------
plot(sbm1, type = "data")
# nodes are ordered wrt to the block they belong to and blocks are highlighted
plot(sbm1, type = "expected")
# fitted connection probabilities
plot(sbm1, type = "meso")
# info on all estimated model is given in
sbm1$storedModels
sbm1$memberships
plot(graph, vertex.color = sbm1$memberships)
plotMyMatrix(fungusTreeNetwork$tree_tree,
dimLabels = list(row = 'tree', col = 'tree'))
# let us consider poisson distributed variables Y_ij
sbm2 = estimateSimpleSBM(Yw, "poisson", dimLabels = 'tree',
estimOptions = list(verbosity = 1))
sbm2
# selected number of blocks
sbm2$nbBlocks
# prior block probabilities
sbm2$blockProp
# connectivity parameters
round(sbm2$connectParam$mean,3)
plot(sbm2, type = "data", dimLabels = list(row = 'tree', col= 'tree'))
# or the average number of connections between trees
plot(sbm2, type = "expected", dimLabels = list(row = 'tree', col= 'tree'))
# or
plot(sbm2, type = "meso", dimLabels = list(row = 'tree', col= 'tree'))
plot(sbm2, type = "data", dimLabels = list(row = 'tree', col= 'tree'))
summary(eigen_centrality)
install.packages('IRkernel')
install.packages('IRkernel')
IRkernel::installspec()
install.packages("pandoc")
rm(list = ls())
library(igraph)
library(ergm)
library(intergraph)
library(sbm)
library(ggplot2)
library(gridExtra)
setwd("~/R files/R-Project")
load("workspace.Rdata")
mod1 <- ergm(net ~ edges + receiver + sender,
control = control.ergm(seed = 1))
summary(mod1)
View(mod1_receiverAndSender)
summary(mod1_receiver)
#SRG
SRG_model <- mod0
#SRG
model_SRG <- mod0
#NH-SRG
model_NHSRG <- mod1
model_NHSRG_onlyReceiver <- mod1_receiver
#could not be estimated (neanche dal mio fisso)
model_P1_onlyMutual <- mod2_mutual
summary(model_P1_onlyMutual)
mod2_allAttributes <- ergm(net ~ edges + mutual +
nodecov("gdp") + nodefactor("continent") + nodefactor("partition") +
absdiff("gdp") + nodematch("continent") + nodematch("partition"),
control = control.ergm(seed = 1))
model_P1_onlyMutual_AllAttributes <- ergm(net ~ edges + mutual +
nodecov("gdp") + nodefactor("continent") + nodefactor("partition") +
absdiff("gdp") + nodematch("continent") + nodematch("partition"),
control = control.ergm(seed = 1))
summary(model_P1_onlyMutual_AllAttributes)
model_P1_onlyMutual_AllAttributes_woPartitionHomophily <- ergm(net ~ edges + mutual +
nodecov("gdp") + nodefactor("continent") + nodefactor("partition") +
absdiff("gdp") + nodematch("continent"),
control = control.ergm(seed = 1))
model_P1_onlyMutual_NodeAttr <- model_P1_onlyMutual_AllAttributes
model_P1_onlyMutual_NodeAttr_noPartitionHomophily <- ergm(net ~ edges + mutual +
nodecov("gdp") + nodefactor("continent") + nodefactor("partition") +
absdiff("gdp") + nodematch("continent"),
control = control.ergm(seed = 1))
# Degeneracy
mod3
model_Markov_onlyIStar2 <- mod3_onlyIStar2
summary(model_Markov_onlyIStar2)
model_Markov_onlyIStar2_noPartitionHomophily <- mod3_onlyIStar2_noPartitionHomophily
summary(model_Markov_onlyIStar2_noPartitionHomophily)
save.image("~/R files/R-Project/workspace.RData")
model_Markov_AlternatingKStar_onlyOutKStar <- mod4_onlyGwod
# Done
model_Markov_AlternatingKStar_onlyOutKStar_noPartitionHomophily_noGDPMain <- mod4_onlyGwod_noPartitionHomophily_noGDPMain
summary(model_Markov_AlternatingKStar_onlyOutKStar_noPartitionHomophily_noGDPMain)
model_Markov_AlternatingKStar_onlyInKStar <- mod4_onlyGwid
# Degeneracy
model_Markov_onlyAlternatingOutKStar <- model_Markov_AlternatingKStar_onlyOutKStar
# Done
model_Markov_onlyAlternatingOutKStar_noPartitionHomophily_noGDPMain <- model_Markov_AlternatingKStar_onlyOutKStar_noPartitionHomophily_noGDPMain
# Done
model_Markov_onlyAlternatingInKStar <- mod4_onlyGwid
# Done
model_Markov_onlyAlternatingInKStar_noPartitionHomophily <- mod4_onlyGwid_noPartitionHomophily
#trying
model_SocialCirtcuit_onlyK2Paths <- mod5_gwdsp
model_SocialCirtcuit_onlyK2Paths_NoMutualEffect_NoGDPMain <- mod5_gwdsp_NoMutualEffect_NoGDPMain
save.image("~/R files/R-Project/workspace.RData")
